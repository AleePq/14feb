<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'>
    <title>Para ti, mi amor ❤️</title>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
            /* Safe area para móviles con notch */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        body {
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #canvas-wrap {
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
            border: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id='canvas-wrap'>
        <canvas id='canvas'></canvas>
    </div>
    
    <!-- Iframe oculto para reproducir la canción de YouTube -->
    <iframe width='0' height='0' src='https://www.youtube.com/embed/9KIshSBiojI?autoplay=1&loop=1&playlist=9KIshSBiojI' frameborder='0' allow='autoplay; encrypted-media'></iframe>

    <script>
        // Obtenemos el canvas y el contexto
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const wrap = document.getElementById('canvas-wrap');
        
        // Tamaño del canvas responsivo (móvil y escritorio)
        function resizeCanvas() {
            let w = wrap.clientWidth;
            let h = wrap.clientHeight;
            if (!w || !h) { w = window.innerWidth; h = window.innerHeight; }
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                heartFormed = false;
                flowers.length = 0;
            }
        }
        let heartFormed = false;
        const flowers = [];
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', function() { setTimeout(resizeCanvas, 100); });

        // Funciones para la forma paramétrica del corazón (t de 0 a 2π)
        function heartPos(t, scale, cx, cy) {
            const px = scale * 16 * Math.pow(Math.sin(t), 3);
            const py = -scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            return { x: cx + px, y: cy + py };
        }
        function heartTangent(t, scale) {
            const eps = 0.001;
            const p1 = heartPos(t - eps, scale, 0, 0);
            const p2 = heartPos(t + eps, scale, 0, 0);
            const dx = (p2.x - p1.x) / (2 * eps);
            const dy = (p2.y - p1.y) / (2 * eps);
            const len = Math.sqrt(dx*dx + dy*dy) || 1;
            return { x: dx/len, y: dy/len };
        }
        function heartNormal(t, scale) {
            const tng = heartTangent(t, scale);
            return { x: -tng.y, y: tng.x };
        }

        // Definimos la clase Point con propiedades x e y (inicializadas en 0 si no se proporcionan valores)
        class Point {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
        }

        // Definimos la clase Particle con las propiedades especificadas
        class Particle {
            constructor() {
                // Posición inicial aleatoria: empieza arriba del canvas
                this.position = new Point(
                    Math.random() * canvas.width,
                    Math.random() * -50
                );
                
                // Velocidad con movimiento lateral ligero y caída hacia abajo
                this.velocity = new Point(
                    (Math.random() - 0.5) * 2, // Movimiento lateral ligero
                    Math.random() * 3 + 1       // Caída
                );
                
                // Aceleración (gravedad ligera)
                this.acceleration = new Point(0, 0.05);
                
                // Edad y vida de la partícula
                this.age = 0;
                this.life = Math.random() * 200 + 300; // Entre 300 y 500 frames
                
                // Variable para controlar si la partícula debe formar parte del corazón
                this.inHeartFormation = false;
                this.heartX = 0;
                this.heartY = 0;
            }

            // Método para crear la forma de un corazón
            createHeartShape() {
                // Escala adaptativa para móvil y pantallas pequeñas
                const scale = Math.min(12, canvas.width / 45, canvas.height / 45);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 3; // Colocar el corazón más arriba
                
                // Parámetros para generar puntos dentro de la forma de un corazón
                const t = Math.random() * Math.PI * 2;
                this.heartT = t;
                const pos = heartPos(t, scale, centerX, centerY);
                this.originalHeartX = pos.x;
                this.originalHeartY = pos.y;
                this.heartScale = scale;
                this.heartCenterX = centerX;
                this.heartCenterY = centerY;
                this.heartX = pos.x;
                this.heartY = pos.y;
                this.inHeartFormation = true;
                
                this.timeOffset = Math.random() * Math.PI * 2;
            }

            // Método update para actualizar posición y estado
            update() {
                // Si la partícula debe formar parte del corazón, moverla hacia la posición del corazón
                if (this.inHeartFormation) {
                    const time = Date.now() * 0.001;
                    const flowSpeed = 0.4;
                    const spiralAmp = 8;
                    const spiralFreq = 2.5;
                    const spiralWraps = 6;
                    
                    // Flujo a lo largo del corazón + espiral perpendicular a la curva
                    let t = this.heartT + time * flowSpeed + this.timeOffset * 0.5;
                    t = ((t % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    const basePos = heartPos(t, this.heartScale, this.heartCenterX, this.heartCenterY);
                    const normal = heartNormal(t, this.heartScale);
                    const spiralPhase = spiralFreq * time + this.timeOffset + t * spiralWraps;
                    const offset = spiralAmp * Math.sin(spiralPhase) + spiralAmp * 0.3 * Math.sin(spiralPhase * 2);
                    
                    const baseX = basePos.x + normal.x * offset;
                    const baseY = basePos.y + normal.y * offset;
                    this.originalHeartX = baseX;
                    this.originalHeartY = baseY;
                    this.position.x = baseX;
                    this.position.y = baseY;
                } else {
                    // Actualizar velocidad con aceleración
                    this.velocity.x += this.acceleration.x;
                    this.velocity.y += this.acceleration.y;
                    
                    // Actualizar posición con velocidad
                    this.position.x += this.velocity.x;
                    this.position.y += this.velocity.y;
                }
                
                // Incrementar edad
                this.age++;
            }

            // Método render para dibujar la partícula
            render() {
                // Controlar la opacidad según la edad de la partícula
                let alpha = 1;
                if (this.age < 50) {
                    // Fade in: la partícula aparece gradualmente
                    alpha = this.age / 50;
                } else if (this.age > this.life - 50) {
                    // Fade out: la partícula desaparece gradualmente
                    alpha = (this.life - this.age) / 50;
                }
                
                // Efecto de holograma con partículas rojas brillantes
                const glowIntensity = this.inHeartFormation ? 0.8 : 0.5;
                
                // Halo exterior brillante
                const gradient = ctx.createRadialGradient(
                    this.position.x, this.position.y, 0,
                    this.position.x, this.position.y, 8
                );
                gradient.addColorStop(0, `rgba(255, 50, 80, ${alpha * glowIntensity})`);
                gradient.addColorStop(0.5, `rgba(255, 30, 60, ${alpha * glowIntensity * 0.4})`);
                gradient.addColorStop(1, `rgba(255, 0, 40, 0)`);
                
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Núcleo brillante de la partícula
                ctx.fillStyle = `rgba(255, 100, 120, ${alpha})`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Punto central super brillante
                ctx.fillStyle = `rgba(255, 200, 220, ${alpha * 0.9})`;
                ctx.beginPath();
                ctx.arc(this.position.x, this.position.y, 1, 0, Math.PI * 2);
                ctx.fill();
            }
        }

        // Array para almacenar todas las partículas
        const particles = [];

        // Número de partículas que forman el corazón
        const numHeartParticles = 1000;

        // Texto de la carta de amor
        const letterText = `Mi amor,

Desde el momento en que entraste en mi vida, todo cambió. El mundo se volvió más brillante, los días más luminosos y cada instante más significativo. No existen palabras suficientes para expresar lo que siento por ti, pero lo intentaré...

Eres la razón por la que sonrío sin motivo aparente, la inspiración detrás de mis sueños más hermosos, y la paz que encuentro en medio del caos. Tu risa es mi melodía favorita, tus ojos el universo en el que me pierdo, y tu corazón el hogar que siempre he buscado.

Cada día a tu lado es un regalo. Me enseñas el verdadero significado del amor: no solo con palabras, sino con cada gesto, cada mirada, cada momento compartido. Contigo he aprendido que el amor no es perfecto, pero es real, profundo y transformador.

Quiero que sepas que estoy aquí, no solo en los momentos felices, sino también en las tormentas. Juntos podemos enfrentar cualquier desafío, porque cuando estamos unidos, somos invencibles.

Gracias por elegirme, por amarme tal como soy, y por llenar mi vida de tanto amor y felicidad. Prometo cuidarte, valorarte y amarte todos los días de mi vida.

Eres mi presente y mi futuro, mi compañera y mi mejor amiga. Te amo más de lo que las palabras pueden decir, y menos de lo que mi corazón siente.

Con todo mi amor,
Tuyo por siempre ❤️`;

        // Variables para controlar el despliegue de la carta
        let showingLetter = false;
        let letterScrollY = 0;
        const scrollStep = 30;
        const maxScroll = 1200; // Ajustar según el texto real
        let heart3DRotation = 0;

        // Función para dibujar la carta de amor
        function drawLetter() {
            ctx.save();
            
            // Crear un fondo semitransparente para la carta
            const margin = 50;
            const letterWidth = canvas.width - margin * 2;
            const letterHeight = canvas.height - margin * 2;
            const letterX = margin;
            const letterY = margin;
            
            // Fondo de la carta con sombra
            ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
            ctx.fillRect(letterX, letterY, letterWidth, letterHeight);
            
            // Borde decorativo
            ctx.strokeStyle = 'rgba(255, 80, 110, 0.4)';
            ctx.lineWidth = 4;
            ctx.strokeRect(letterX + 10, letterY + 10, letterWidth - 20, letterHeight - 20);
            
            // Resetear sombra para el texto
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Configurar el texto
            ctx.fillStyle = '#333';
            const baseFontSize = Math.max(14, Math.min(18, canvas.width / 30));
            ctx.font = `${baseFontSize}px Georgia, serif`;
            ctx.textAlign = 'left';
            ctx.textBaseline = 'top';
            
            // Área de texto visible (con margen interno)
            const textMargin = 30;
            const textX = letterX + textMargin;
            const textY = letterY + textMargin;
            const textWidth = letterWidth - textMargin * 2;
            const textHeight = letterHeight - textMargin * 2 - 40; // Espacio para el botón de cerrar
            
            // Crear región de recorte para el texto (scroll)
            ctx.save();
            ctx.beginPath();
            ctx.rect(textX, textY, textWidth, textHeight);
            ctx.clip();
            
            // Dibujar el texto con desplazamiento vertical (scroll)
            const lineHeight = baseFontSize * 1.8;
            const lines = letterText.split('\n');
            let currentY = textY - letterScrollY;
            
            for (const line of lines) {
                if (currentY + lineHeight > textY - 50 && currentY < textY + textHeight + 50) {
                    if (line.trim() === '') {
                        currentY += lineHeight / 2;
                    } else {
                        const words = line.split(' ');
                        let currentLine = '';
                        let testLine = '';
                        
                        for (let i = 0; i < words.length; i++) {
                            testLine = currentLine + words[i] + ' ';
                            const metrics = ctx.measureText(testLine);
                            
                            if (metrics.width > textWidth && i > 0) {
                                ctx.fillText(currentLine.trim(), textX, currentY);
                                currentLine = words[i] + ' ';
                                currentY += lineHeight;
                            } else {
                                currentLine = testLine;
                            }
                        }
                        
                        ctx.fillText(currentLine.trim(), textX, currentY);
                        currentY += lineHeight;
                    }
                } else {
                    // Línea fuera del área visible, pero hay que calcular su espacio
                    if (line.trim() === '') {
                        currentY += lineHeight / 2;
                    } else {
                        const words = line.split(' ');
                        let currentLine = '';
                        
                        for (let i = 0; i < words.length; i++) {
                            const testLine = currentLine + words[i] + ' ';
                            const metrics = ctx.measureText(testLine);
                            
                            if (metrics.width > textWidth && i > 0) {
                                currentLine = words[i] + ' ';
                                currentY += lineHeight;
                            } else {
                                currentLine = testLine;
                            }
                        }
                        currentY += lineHeight;
                    }
                }
            }
            
            ctx.restore(); // Terminar el recorte
            
            // Botón de cerrar (esquina superior derecha)
            const closeButtonWidth = Math.min(100, canvas.width * 0.25);
            const closeButtonHeight = Math.max(36, canvas.height * 0.055);
            const closeButtonX = canvas.width - closeButtonWidth - 20;
            const closeButtonY = 55;
            
            ctx.fillStyle = 'rgba(255, 100, 100, 0.8)';
            ctx.fillRect(closeButtonX, closeButtonY, closeButtonWidth, closeButtonHeight);
            
            ctx.fillStyle = '#fff';
            ctx.font = `${Math.max(14, baseFontSize * 0.9)}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Cerrar', closeButtonX + closeButtonWidth / 2, closeButtonY + closeButtonHeight / 2);
            
            ctx.restore();
        }

        function getButtonRect() {
            const buttonWidth = Math.min(200, canvas.width * 0.45);
            const buttonHeight = Math.max(50, canvas.height * 0.08);
            const buttonX = (canvas.width - buttonWidth) / 2;
            const buttonY = canvas.height * 0.65;
            return { x: buttonX, y: buttonY, w: buttonWidth, h: buttonHeight };
        }

        // Función para dibujar el botón debajo del corazón (solo visible si no está mostrando la carta)
        function drawButton() {
            if (showingLetter) return; // No mostrar el botón si la carta está visible
            
            ctx.save();
            
            const btn = getButtonRect();
            
            // Sombra del botón
            ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 3;
            ctx.shadowOffsetY = 3;
            
            // Fondo del botón con gradiente rojo
            const grad = ctx.createLinearGradient(btn.x, btn.y, btn.x, btn.y + btn.h);
            grad.addColorStop(0, 'rgba(255, 60, 90, 0.95)');
            grad.addColorStop(1, 'rgba(220, 40, 70, 0.95)');
            ctx.fillStyle = grad;
            ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
            
            // Borde del botón
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 3;
            ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
            
            // Resetear sombra
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;
            
            // Texto del botón
            ctx.fillStyle = '#fff';
            const buttonFontSize = Math.max(16, Math.min(22, canvas.width / 25));
            ctx.font = `bold ${buttonFontSize}px Arial, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Lee mi carta ❤️', btn.x + btn.w / 2, btn.y + btn.h / 2);
            
            ctx.restore();
        }

        // Función principal de animación
        function animate() {
            // Limpiar el canvas con un fondo oscuro
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Si el corazón no se ha formado completamente, crear partículas hasta completarlo
            if (!heartFormed) {
                if (particles.length < numHeartParticles) {
                    const newParticle = new Particle();
                    newParticle.createHeartShape();
                    particles.push(newParticle);
                } else {
                    heartFormed = true;
                }
            }
            
            // Actualizar y renderizar cada partícula
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.update();
                p.render();
                
                // Si la partícula ha llegado al final de su vida y no está en formación de corazón, eliminarla
                if (p.age > p.life && !p.inHeartFormation) {
                    particles.splice(i, 1);
                }
            }
            
            // Añadir nuevas partículas de fondo si el corazón ya está formado
            if (heartFormed && Math.random() < 0.1) {
                const p = new Particle();
                particles.push(p);
            }
            
            // Actualizar rotación 3D del corazón
            heart3DRotation += 0.0015;
            
            // Dibujar el resplandor del núcleo del corazón
            drawHeartCoreGlow();
            
            // Dibujar el contorno del corazón
            drawHeartOutline();
            
            // Dibujar flores donde el usuario haya tocado/cliqueado
            for (const flower of flowers) {
                drawFlower(flower.x, flower.y);
            }
            
            // Dibujar el botón si la carta no está visible
            if (!showingLetter) {
                drawButton();
            }
            
            // Si se está mostrando la carta, dibujarla
            if (showingLetter) {
                drawLetter();
            }
            
            // Solicitar el siguiente frame
            requestAnimationFrame(animate);
        }

        // Función para dibujar una flor
        function drawFlower(x, y) {
            // Centro de la flor
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 200, 100, 0.9)'; // Amarillo para el centro
            ctx.fill();
            
            // Pétalos de la flor (6 pétalos alrededor del centro)
            for (let i = 0; i < 6; i++) {
                const angle = (Math.PI * 2 / 6) * i;
                ctx.beginPath();
                ctx.ellipse(
                    x + 25 * Math.cos(angle),   // Posición x del pétalo
                    y + 25 * Math.sin(angle),   // Posición y del pétalo
                    20,                         // Ancho del pétalo
                    10,                         // Alto del pétalo
                    angle,                      // Rotación del pétalo
                    0,                          // Inicio del arco
                    Math.PI * 2                 // Fin del arco
                );
                
                ctx.fillStyle = 'rgba(255, 105, 180, 0.8)'; // Rosa semitransparente
                ctx.fill();
            }
        }
        
        // Obtener coordenadas en espacio del canvas (soporta ratón y tacto)
        function getCanvasCoords(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const ev = event.touches ? event.touches[0] : event;
            return {
                x: (ev.clientX - rect.left) * scaleX,
                y: (ev.clientY - rect.top) * scaleY
            };
        }
        
        function handleTap(x, y) {
            const btn = getButtonRect();
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                showingLetter = true;
                letterScrollY = 0;
                return;
            }
            const closeW = Math.min(100, canvas.width * 0.25);
            const closeH = Math.max(36, canvas.height * 0.055);
            const closeX = canvas.width - closeW - 20;
            const closeY = 55;
            if (showingLetter && x >= closeX && x <= canvas.width - 20 && y >= closeY && y <= closeY + closeH) {
                showingLetter = false;
                return;
            }
            if (showingLetter && x >= 50 && x <= canvas.width - 50 && y >= 50 && y <= canvas.height - 50) {
                letterScrollY = Math.min(letterScrollY + scrollStep, maxScroll);
                return;
            }
            if (!showingLetter) {
                flowers.push({ x: x, y: y });
            }
        }
        
        canvas.addEventListener('click', function(event) {
            const coords = getCanvasCoords(event);
            handleTap(coords.x, coords.y);
        });
        
        // Soporte táctil: evitar doble disparo con click y usar touch
        let lastTouchEnd = 0;
        canvas.addEventListener('touchend', function(event) {
            if (event.changedTouches.length) {
                const t = event.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (t.clientX - rect.left) * scaleX;
                const y = (t.clientY - rect.top) * scaleY;
                const now = Date.now();
                if (now - lastTouchEnd < 300) return;
                lastTouchEnd = now;
                event.preventDefault();
                handleTap(x, y);
            }
        }, { passive: false });
        
        // Desplazar la carta con la rueda del ratón
        canvas.addEventListener('wheel', function(event) {
            if (showingLetter) {
                event.preventDefault();
                if (event.deltaY > 0) {
                    letterScrollY = Math.min(letterScrollY + scrollStep, maxScroll);
                } else {
                    letterScrollY = Math.max(0, letterScrollY - scrollStep);
                }
            }
        }, { passive: false });
        
        // Desplazar la carta con el dedo (móvil)
        let touchStartY = 0;
        let scrollStartY = 0;
        canvas.addEventListener('touchstart', function(event) {
            if (showingLetter && event.touches.length === 1) {
                touchStartY = event.touches[0].clientY;
                scrollStartY = letterScrollY;
            }
        }, { passive: true });
        canvas.addEventListener('touchmove', function(event) {
            if (showingLetter && event.touches.length === 1) {
                event.preventDefault();
                const dy = touchStartY - event.touches[0].clientY;
                letterScrollY = Math.max(0, Math.min(maxScroll, scrollStartY + dy));
            }
        }, { passive: false });

        function drawHeartCoreGlow() {
            ctx.save();
            const cx = canvas.width / 2;
            const cy = canvas.height / 3;
            const pulse = 1 + 0.08 * Math.sin(Date.now() * 0.003);
            const r = Math.min(canvas.width, canvas.height) * 0.4 * pulse;
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            grad.addColorStop(0, 'rgba(255, 50, 80, 0.25)');
            grad.addColorStop(0.3, 'rgba(255, 30, 60, 0.15)');
            grad.addColorStop(0.6, 'rgba(200, 20, 50, 0.08)');
            grad.addColorStop(1, 'rgba(150, 0, 30, 0)');
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = grad;
            ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
            ctx.restore();
        }

        function drawHeartOutline() {
            ctx.save();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 3;
            const outlineScale = Math.min(8, canvas.width / 70, canvas.height / 70);
            const cosAngle = Math.cos(heart3DRotation);
            const sinAngle = Math.sin(heart3DRotation);
            
            const sideView = 1 - Math.abs(cosAngle);
            
            function buildHeartPath(offsetX, offsetY) {
                ctx.beginPath();
                for (let t = 0; t < Math.PI * 2; t += 0.04) {
                    const px = outlineScale * 16 * Math.pow(Math.sin(t), 3);
                    const py = -outlineScale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    const depthFactor = px / (outlineScale * 20);
                    const rotX = px * cosAngle + depthFactor * sinAngle * outlineScale * (3 + sideView * 2);
                    const scaleD = Math.max(0.5 - sideView * 0.2, 1 - Math.abs(depthFactor) * (0.25 + sideView * 0.2));
                    const tiltY = depthFactor * sinAngle * outlineScale * 2 * sideView;
                    const x = centerX + rotX * scaleD + offsetX;
                    const y = centerY + py + tiltY + offsetY;
                    t === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.closePath();
            }
            
            // Sombra más dramática para efecto holograma
            const shadowOffset = 6 + (12 + sideView * 16) * Math.abs(sinAngle);
            buildHeartPath(shadowOffset, shadowOffset);
            ctx.fillStyle = `rgba(80, 0, 20, ${0.5 + sideView * 0.3})`;
            ctx.fill();
            
            // Relleno sutil del corazón con rojo
            buildHeartPath(0, 0);
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `rgba(255, 40, 70, ${0.05 + 0.03 * (1 - sideView)})`;
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            
            // Múltiples capas de contorno rojo para efecto de holograma
            for (let i = 0; i < 6; i++) {
                const offset = (i - 2.5) * 2.5;
                const alpha = 0.7 - i * 0.1;
                buildHeartPath(offset, offset);
                ctx.strokeStyle = `rgba(255, 50, 80, ${alpha})`;
                ctx.lineWidth = 3;
                ctx.stroke();
            }
            
            // Contorno principal brillante
            buildHeartPath(0, 0);
            ctx.strokeStyle = `rgba(255, 80, 110, ${0.95})`;
            ctx.lineWidth = 2.5;
            ctx.stroke();
            
            // Línea interior super brillante (efecto holograma)
            buildHeartPath(0, 0);
            ctx.strokeStyle = 'rgba(255, 150, 170, 0.6)';
            ctx.lineWidth = 1.2;
            ctx.stroke();
            
            // Línea exterior extra brillante
            buildHeartPath(0, 0);
            ctx.strokeStyle = 'rgba(255, 200, 220, 0.4)';
            ctx.lineWidth = 0.8;
            ctx.stroke();
            
            ctx.restore();
        }

        // Iniciar la animación
        animate();
    </script>
</body>
</html>