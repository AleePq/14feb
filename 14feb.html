<!DOCTYPE html>
<html lang='es'>
<head>
    <meta charset='UTF-8'>
    <meta name='viewport' content='width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover'>
    <title>Para ti, mi amor - Viento de Caifanes ❤️</title>
    <style>
        * { box-sizing: border-box; }
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            -webkit-overflow-scrolling: touch;
            touch-action: manipulation;
            /* Safe area para móviles con notch */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
            padding-top: env(safe-area-inset-top);
            padding-bottom: env(safe-area-inset-bottom);
        }
        body {
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #canvas-wrap {
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
            max-width: 100%;
            max-height: 100%;
            border: none;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }
    </style>
</head>
<body>
    <div id='canvas-wrap'>
        <canvas id='canvas'></canvas>
    </div>
    
    <!-- Iframe oculto para reproducir la canción de YouTube -->
    <iframe width='0' height='0' src='https://www.youtube.com/embed/NMlKHIqtuO0?autoplay=1&loop=1&playlist=NMlKHIqtuO0' frameborder='0' allow='autoplay; encrypted-media'></iframe>

    <script>
        // Obtenemos el canvas y el contexto
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const wrap = document.getElementById('canvas-wrap');
        
        // Tamaño del canvas responsivo (móvil y escritorio)
        function resizeCanvas() {
            let w = wrap.clientWidth;
            let h = wrap.clientHeight;
            if (!w || !h) { w = window.innerWidth; h = window.innerHeight; }
            if (canvas.width !== w || canvas.height !== h) {
                canvas.width = w;
                canvas.height = h;
                heartFormed = false;
                flowers.length = 0;
            }
        }
        let heartFormed = false;
        const flowers = [];
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        window.addEventListener('orientationchange', function() { setTimeout(resizeCanvas, 100); });

        // Funciones para la forma paramétrica del corazón (t de 0 a 2π)
        function heartPos(t, scale, cx, cy) {
            const px = scale * 16 * Math.pow(Math.sin(t), 3);
            const py = -scale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
            return { x: cx + px, y: cy + py };
        }
        function heartTangent(t, scale) {
            const eps = 0.001;
            const p1 = heartPos(t - eps, scale, 0, 0);
            const p2 = heartPos(t + eps, scale, 0, 0);
            const dx = (p2.x - p1.x) / (2 * eps);
            const dy = (p2.y - p1.y) / (2 * eps);
            const len = Math.sqrt(dx*dx + dy*dy) || 1;
            return { x: dx/len, y: dy/len };
        }
        function heartNormal(t, scale) {
            const tng = heartTangent(t, scale);
            return { x: -tng.y, y: tng.x };
        }

        // Definimos la clase Point con propiedades x e y (inicializadas en 0 si no se proporcionan valores)
        class Point {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
        }

        // Definimos la clase Particle con las propiedades especificadas
        class Particle {
            constructor() {
                // Posición inicial aleatoria: empieza arriba del canvas
                this.position = new Point(
                    Math.random() * canvas.width,
                    Math.random() * -50
                );
                
                // Velocidad con movimiento lateral ligero y caída hacia abajo
                this.velocity = new Point(
                    (Math.random() - 0.5) * 2, // Movimiento lateral ligero
                    Math.random() * 3 + 1       // Caída
                );
                
                // Aceleración (gravedad ligera)
                this.acceleration = new Point(0, 0.05);
                
                // Edad y vida de la partícula
                this.age = 0;
                this.life = Math.random() * 200 + 300; // Entre 300 y 500 frames
                
                // Variable para controlar si la partícula debe formar parte del corazón
                this.inHeartFormation = false;
                this.heartX = 0;
                this.heartY = 0;
            }

            // Método para crear la forma de un corazón
            createHeartShape() {
                // Escala adaptativa para móvil y pantallas pequeñas
                const scale = Math.min(12, canvas.width / 45, canvas.height / 45);
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 3; // Colocar el corazón más arriba
                
                // Parámetros para generar puntos dentro de la forma de un corazón
                const t = Math.random() * Math.PI * 2;
                this.heartT = t;
                const pos = heartPos(t, scale, centerX, centerY);
                this.originalHeartX = pos.x;
                this.originalHeartY = pos.y;
                this.heartScale = scale;
                this.heartCenterX = centerX;
                this.heartCenterY = centerY;
                this.heartX = pos.x;
                this.heartY = pos.y;
                this.inHeartFormation = true;
                
                this.timeOffset = Math.random() * Math.PI * 2;
            }

            // Método update para actualizar posición y estado
            update() {
                // Si la partícula debe formar parte del corazón, moverla hacia la posición del corazón
                if (this.inHeartFormation) {
                    const time = Date.now() * 0.001;
                    const flowSpeed = 0.4;
                    const spiralAmp = 8;
                    const spiralFreq = 2.5;
                    const spiralWraps = 6;
                    
                    // Flujo a lo largo del corazón + espiral perpendicular a la curva
                    let t = this.heartT + time * flowSpeed + this.timeOffset * 0.5;
                    t = ((t % (Math.PI * 2)) + Math.PI * 2) % (Math.PI * 2);
                    const basePos = heartPos(t, this.heartScale, this.heartCenterX, this.heartCenterY);
                    const normal = heartNormal(t, this.heartScale);
                    const spiralPhase = spiralFreq * time + this.timeOffset + t * spiralWraps;
                    const offset = spiralAmp * Math.sin(spiralPhase) + spiralAmp * 0.3 * Math.sin(spiralPhase * 2);
                    
                    const baseX = basePos.x + normal.x * offset;
                    const baseY = basePos.y + normal.y * offset;
                    this.originalHeartX = baseX;
                    this.originalHeartY = baseY;
                    this.position.x = baseX;
                    this.position.y = baseY;
                    
                    // Aplicar efecto 3D (más pronunciado de lado)
                    if (typeof this.heart3DRotation !== 'undefined') {
                        const centerX = canvas.width / 2;
                        const centerY = canvas.height / 3;
                        const rot = this.heart3DRotation;
                        const cosRot = Math.cos(rot);
                        const sinRot = Math.sin(rot);
                        const relX = this.originalHeartX - centerX;
                        const relY = this.originalHeartY - centerY;
                        const maxRadius = Math.min(canvas.width, canvas.height) * 0.25;
                        
                        const depthRaw = relX * sinRot;
                        this.depthNorm = Math.max(-1, Math.min(1, depthRaw / (maxRadius * 0.5)));
                        const sideView = 1 - Math.abs(cosRot);
                        
                        const perspectiveX = relX * cosRot * (1 - this.depthNorm * sideView * 0.4);
                        this.position.x = centerX + perspectiveX;
                        
                        const tiltY = this.depthNorm * sinRot * maxRadius * 0.15 * sideView;
                        this.position.y = baseY + tiltY;
                        
                        const depthScale = sideView > 0.5 ? 0.25 + 0.9 * (this.depthNorm + 1) / 2 : 0.5 + 0.6 * (this.depthNorm + 1) / 2;
                        const rotScale = 0.6 + 0.6 * Math.abs(cosRot);
                        this.currentScale = depthScale * rotScale;
                        
                        this.depthOpacity = sideView > 0.5 ? 0.15 + 0.85 * (this.depthNorm + 1) / 2 : 0.35 + 0.65 * (this.depthNorm + 1) / 2;
                    } else {
                        this.currentScale = 1.0;
                        this.depthOpacity = 1.0;
                    }
                } else {
                    // Si no está en formación del corazón, forzar la formación inmediata
                    this.createHeartShape();
                    this.inHeartFormation = true;
                }
                
                // Incrementamos la edad
                this.age++;
            }
            
            // Método para aplicar rotación 3D al corazón (llamado externamente)
            applyHeartRotation(rotationAngle) {
                if (this.inHeartFormation) {
                    // Calcular la posición relativa al centro del corazón
                    const centerX = canvas.width / 2;
                    const centerY = canvas.height / 3;
                    
                    // Calcular vector desde el centro del corazón a la posición original de la partícula
                    const relX = this.originalHeartX - centerX;
                    const relY = this.originalHeartY - centerY;
                    
                    // Para simular una rotación 3D de izquierda a derecha (rotación en el eje Y)
                    // Proyectamos la posición en 3D y luego la mapeamos de vuelta a 2D
                    const cosAngle = Math.cos(rotationAngle);
                    const sinAngle = Math.sin(rotationAngle);
                    
                    // Rotación en el eje Y (izquierda a derecha)
                    // x' = x*cos(θ) + z*sin(θ), donde z se aproxima con el factor de profundidad
                    // Para simplificar, usaremos una simulación de profundidad basada en la posición X
                    const depthFactor = relX / 200; // Factor de profundidad basado en la posición X
                    const rotatedX = relX * cosAngle + depthFactor * sinAngle * 100; // Ajuste de profundidad
                    const rotatedY = relY; // Mantener Y constante para rotación en eje Y
                    
                    // Calcular factor de escala para efecto de profundidad (más lejos = más pequeño)
                    const scale = 1 - Math.abs(depthFactor) * 0.3; // Reducir tamaño cuando está más lejos
                    
                    // Aplicar el factor de escala y reposicionar
                    this.heartX = centerX + rotatedX * scale;
                    this.heartY = centerY + rotatedY;
                }
            }

            // Método para reiniciar la partícula
            reset() {
                this.position.y = Math.random() * -50; // Nueva posición aleatoria arriba
                this.position.x = Math.random() * canvas.width; // Nueva posición horizontal aleatoria
                this.velocity.x = (Math.random() - 0.5) * 2; // Nuevo movimiento lateral
                this.velocity.y = Math.random() * 3 + 1; // Nueva velocidad de caída
                this.age = 0; // Reiniciar edad
                this.inHeartFormation = false; // Resetear estado de formación del corazón
                delete this.formationStartTime; // Eliminar el tiempo de inicio de formación para reiniciar la transición de color
            }

            getColor() {
                const d = this.depthNorm ?? 0;
                const t = (d + 1) / 2;
                const r = Math.floor(80 + 120 * t);
                const g = Math.floor(150 + 80 * t);
                const b = Math.floor(230 + 25 * t);
                return `rgba(${r}, ${g}, ${b}, 0.85)`;
            }

            // Método draw para dibujar la partícula
            draw() {
                // Calcular radio escalado para efecto 3D
                const baseRadius = this.inHeartFormation ? 1.5 : 1; // Partículas más pequeñas
                const scaledRadius = baseRadius * (this.currentScale || 1.0);
                
                // Si la partícula está formando parte del corazón, usar efecto neon
                if (this.inHeartFormation) {
                    const currentColor = this.getColor();
                    const colorMatch = currentColor.match(/rgba?\((\d+), (\d+), (\d+)/);
                    const r = colorMatch ? parseInt(colorMatch[1]) : 100;
                    const g = colorMatch ? parseInt(colorMatch[2]) : 180;
                    const b = colorMatch ? parseInt(colorMatch[3]) : 255;
                    const alpha = (this.depthOpacity !== undefined ? this.depthOpacity : 1) * 0.92;
                    
                    const cx = this.position.x;
                    const cy = this.position.y;
                    const rot = this.heart3DRotation || 0;
                    const lightX = Math.cos(rot) * 0.8 - Math.sin(rot) * 0.4;
                    const lightY = -0.6;
                    const len = Math.sqrt(lightX*lightX + lightY*lightY) || 1;
                    const hlX = cx - (lightX/len) * scaledRadius * 0.6;
                    const hlY = cy - (lightY/len) * scaledRadius * 0.6;
                    
                    const pulse = 1 + 0.06 * Math.sin(Date.now() * 0.0025);
                    const rad = scaledRadius * pulse;
                    
                    const gradient = ctx.createRadialGradient(hlX, hlY, 0, cx, cy, rad * 3.5);
                    gradient.addColorStop(0, `rgba(255, 255, 255, ${alpha * 0.55})`);
                    gradient.addColorStop(0.15, `rgba(${Math.min(255,r+60)}, ${Math.min(255,g+60)}, 255, ${alpha})`);
                    gradient.addColorStop(0.5, `rgba(${r}, ${g}, ${b}, ${alpha * 0.85})`);
                    gradient.addColorStop(0.85, `rgba(${r}, ${g}, ${b}, ${alpha * 0.3})`);
                    gradient.addColorStop(1, 'rgba(0, 100, 180, 0)');
                    
                    ctx.beginPath();
                    ctx.arc(cx, cy, rad * 3.5, 0, Math.PI * 2);
                    ctx.fillStyle = gradient;
                    ctx.fill();
                    
                    ctx.beginPath();
                    ctx.arc(cx, cy, rad, 0, Math.PI * 2);
                    ctx.strokeStyle = `rgba(${Math.min(255,r+70)}, ${Math.min(255,g+70)}, 255, ${alpha * 0.85})`;
                    ctx.lineWidth = 0.6;
                    ctx.stroke();
                    
                    ctx.shadowColor = `rgba(${r}, ${g}, ${b}, ${alpha * 0.7})`;
                    ctx.shadowBlur = 10;
                    ctx.beginPath();
                    ctx.arc(cx, cy, rad * 0.8, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${alpha})`;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                } else {
                    // Efecto normal para partículas cayendo
                    ctx.beginPath();
                    ctx.arc(this.position.x, this.position.y, scaledRadius, 0, Math.PI * 2); // Círculo con radio escalado
                    ctx.fillStyle = 'rgba(0, 200, 255, 0.7)'; // Azul semitransparente
                    ctx.fill();
                }
            }
        }

        // Array con más partículas para un corazón más denso y vistoso
        const particles = [];
        for (let i = 0; i < 600; i++) {  // Duplicamos la cantidad de partículas
            particles.push(new Particle());
        }
        






        const startTime = Date.now();
        let showingLetter = false; // Variable para controlar si se muestra la carta
        
        // Variables para el efecto 3D y espejo
        let heart3DRotation = 0; // Ángulo de rotación para efecto 3D/espejo
        let rotationDirection = 1; // Dirección de la rotación (1 o -1)
        
        // Botón "Leer Carta" (posiciones calculadas en cada frame para responsividad)
        const buttonWidth = Math.min(150, canvas.width * 0.4);
        const buttonHeight = Math.min(50, canvas.height * 0.08);
        function getButtonRect() {
            const bw = Math.min(150, canvas.width * 0.4);
            const bh = Math.min(50, canvas.height * 0.08);
            const bx = (canvas.width - bw) / 2;
            // Botón debajo de "Te Amo" con espacio suficiente
            const teAmoY = canvas.height / 2 + Math.min(150, canvas.height * 0.22);
            const fontSize = Math.min(60, canvas.width * 0.12, canvas.height * 0.1);
            const by = teAmoY + fontSize * 0.8;
            return { x: bx, y: by, w: bw, h: bh };
        }

        // Función de animación principal
        function animate() {
            // Limpiar el canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Formar el corazón inmediatamente al inicio
            if (!heartFormed) {
                // Formar el corazón con todas las partículas
                for (const particle of particles) {
                    particle.createHeartShape();
                }
                heartFormed = true;
            }
            
            // Incrementar la rotación 3D/espejo
            heart3DRotation += 0.008 * rotationDirection; // Velocidad de rotación para efecto 3D/espejo
            
            // Cambiar dirección cuando alcance cierto ángulo para efecto de rotación completa
            if (heart3DRotation > Math.PI || heart3DRotation < -Math.PI) { // Girar completamente
                rotationDirection *= -1; // Invertir dirección
            }
            
            // Actualizar partículas (rotación 3D antes de update para profundidad correcta)
            for (const particle of particles) {
                particle.heart3DRotation = heart3DRotation;
                particle.update();
            }
            particles.sort((a, b) => (a.depthNorm ?? 0) - (b.depthNorm ?? 0));
            if (heartFormed) drawHeartCoreGlow();
            for (const particle of particles) particle.draw();
            if (heartFormed) drawHeartOutline();
            

            

            
            // Dibujar texto principal 'Te Amo' (tamaño responsivo)
            const fontSize = Math.min(60, canvas.width * 0.12, canvas.height * 0.1);
            ctx.fillStyle = 'rgb(0, 150, 255)'; // Color azul
            ctx.font = 'bold ' + fontSize + 'px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Te Amo', canvas.width / 2, canvas.height / 2 + Math.min(150, canvas.height * 0.22));
            
            // Dibujar botón "Leer Carta" (centrado, responsivo)
            const btn = getButtonRect();
            ctx.fillStyle = '#4a90e2'; // Color azul para el botón
            ctx.fillRect(btn.x, btn.y, btn.w, btn.h);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(btn.x, btn.y, btn.w, btn.h);
            
            // Texto del botón
            ctx.fillStyle = 'white';
            ctx.font = 'bold ' + Math.min(18, canvas.width * 0.045) + 'px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('Leer Carta', btn.x + btn.w/2, btn.y + btn.h/2);
            
            // Si se está mostrando la carta, dibujar el cuadro de texto
            if (showingLetter) {
                // Fondo semi-transparente
                ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                ctx.fillRect(50, 50, canvas.width - 100, canvas.height - 100);
                
                // Borde del cuadro
                ctx.strokeStyle = 'rgba(0, 200, 255, 0.7)';
                ctx.lineWidth = 2;
                ctx.strokeRect(50, 50, canvas.width - 100, canvas.height - 100);
                
                // Texto de la carta
                ctx.fillStyle = 'white';
                ctx.font = '16px Arial';
                ctx.textAlign = 'left';
                
                // Mensaje de la carta (párrafos originales)
                const cartaOriginal = [
                    "Avi, mi amor,",
                    "",
                    "Hola… sé que ayer pasaron muchas cosas, demasiadas emociones de golpe, y que quizás todo fue un torbellino. Pero quiero que sepas que lo último que pasó en la noche era exactamente lo que necesitaba sacar del pecho. Solo estando tomado pude sincerarme de verdad, sin filtros, sin pensar dos veces. Y cada palabra que te dije salió desde lo más hondo, porque era real. Te amo, Avi, y lo hago de verdad, con todo lo que soy.",
                    "",
                    "Cuando me dijiste que me amabas… créeme que me dio una esperanza enorme, de esas que no sentía hace tiempo. Sé que para intentar volver a estar juntos tendré que esperar, y estoy dispuesto a hacerlo todo el tiempo que haga falta. Porque tú vales la pena, vales cada segundo de paciencia.",
                    "",
                    "Sí, nos hicimos daño, y mucho. Lo reconozco. Pero al mismo tiempo nos amamos, y ayer se notó, se sintió en cada mirada, en cada abrazo. No fue solo el alcohol; fue lo que llevamos guardado.",
                    "",
                    "Hoy, 14 de febrero, no es solo el día del amor y la amistad para mí. Es el día en que más hubiera querido pasar contigo, abrazarte sin prisas, demostrarte lo que siento sin miedo. Pero aunque no estemos juntos hoy, quiero decirte algo importante: te invito a salir el lunes, antes de que entres a la escuela. Si quieres faltar un rato al servicio, o solo escaparnos un momento… salgamos a comer algo, a platicar tranquilos, tú y yo solos. Sin alcohol de por medio, sin preocupaciones de qué pasará mañana. Solo disfrutar un rato como ayer, pero con la calma de saber que podemos demostrarnos cariño sin que se acabe al día siguiente.",
                    "",
                    "Te amo más de lo que las palabras pueden decir, y ayer quise que lo supieras de una vez. Me encantó salir contigo, verte sonreír, sentirte cerca. No te preocupes, sé que no eres de las que juegan o lastiman a propósito, por eso todavía confío en ti… aunque quizás tú ya no lo hagas en mí. Lo entiendo, y lo voy a respetar.",
                    "",
                    "Es todo por ahora, Avi. Descansa, cuídate mucho. Dudo que contestes pronto, y está bien. Solo necesitaba que leyeras esto, o que lo escucharas, y que supieras que mi corazón sigue aquí, esperándote si algún día decides volver a intentarlo.",
                    "",
                    "Te amo.",
                    "",
                    "Cuídate, por favor.",
                    "",
                    "Te amo."
                ];
                
                // Ajustar texto al ancho del cuadro (word wrap) para que se lea bien
                const maxLineWidth = canvas.width - 140;
                const lineHeight = 22;
                const carta = [];
                ctx.font = '15px Georgia, serif';
                for (let p = 0; p < cartaOriginal.length; p++) {
                    const parrafo = cartaOriginal[p];
                    if (parrafo === "") {
                        carta.push("");
                        continue;
                    }
                    const palabras = parrafo.split(" ");
                    let linea = "";
                    for (let w = 0; w < palabras.length; w++) {
                        const prueba = linea ? linea + " " + palabras[w] : palabras[w];
                        const ancho = ctx.measureText(prueba).width;
                        if (ancho <= maxLineWidth) {
                            linea = prueba;
                        } else {
                            if (linea) carta.push(linea);
                            linea = palabras[w];
                        }
                    }
                    if (linea) carta.push(linea);
                }
                maxScroll = Math.max(0, carta.length * lineHeight - (canvas.height - 130));
                
                // Dibujar cada línea del texto con desplazamiento
                ctx.font = '15px Georgia, serif';
                for (let i = 0; i < carta.length; i++) {
                    const yPos = 80 + i * lineHeight - letterScrollY;
                    if (yPos > 50 && yPos < canvas.height - 50) {
                        ctx.fillText(carta[i], 70, yPos);
                    }
                }
                
                // Indicador de desplazamiento (texto corto en móvil)
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.font = (canvas.width < 400 ? '11px' : '12px') + ' Arial';
                ctx.textAlign = 'right';
                ctx.fillText(canvas.width < 400 ? 'Desliza para leer' : 'Rueda del ratón o toca para desplazar', canvas.width - 20, canvas.height - 15);
                
                // Botón de cerrar (tamaño táctil en móvil)
                const closeW = Math.min(100, canvas.width * 0.25);
                const closeH = Math.max(36, canvas.height * 0.055);
                const closeX = canvas.width - closeW - 20;
                const closeY = 55;
                ctx.fillStyle = '#e74c3c';
                ctx.fillRect(closeX, closeY, closeW, closeH);
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 1;
                ctx.strokeRect(closeX, closeY, closeW, closeH);
                ctx.fillStyle = 'white';
                ctx.font = 'bold ' + Math.min(14, canvas.width * 0.035) + 'px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Cerrar', closeX + closeW/2, closeY + closeH/2);
            }
            
            // Dibujar todas las flores
            for (const flower of flowers) {
                drawFlower(flower.x, flower.y);
            }
            // Continuar la animación
            requestAnimationFrame(animate);
        }
        
        // Variables para el desplazamiento de la carta
        let letterScrollY = 0;
        let maxScroll = 500;
        const scrollStep = 30; // Cantidad de píxeles por paso de desplazamiento
        
        // Función para dibujar una flor en la posición (x, y)
        function drawFlower(x, y) {
            // Centro de la flor
            ctx.beginPath();
            ctx.arc(x, y, 10, 0, Math.PI * 2);
            ctx.fillStyle = 'yellow';
            ctx.fill();
            
            // Dibujar 6 pétalos
            for (let i = 0; i < 6; i++) {
                const angle = i * Math.PI / 3; // Dividir en 6 partes iguales (60 grados)
                
                ctx.beginPath();
                // Usamos ellipse para crear los pétalos
                ctx.ellipse(
                    x + 25 * Math.cos(angle),   // Posición x del pétalo
                    y + 25 * Math.sin(angle),   // Posición y del pétalo
                    20,                         // Ancho del pétalo
                    10,                         // Alto del pétalo
                    angle,                      // Rotación del pétalo
                    0,                          // Inicio del arco
                    Math.PI * 2                 // Fin del arco
                );
                
                ctx.fillStyle = 'rgba(255, 105, 180, 0.8)'; // Rosa semitransparente
                ctx.fill();
            }
        }
        
        // Obtener coordenadas en espacio del canvas (soporta ratón y tacto)
        function getCanvasCoords(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const ev = event.touches ? event.touches[0] : event;
            return {
                x: (ev.clientX - rect.left) * scaleX,
                y: (ev.clientY - rect.top) * scaleY
            };
        }
        
        function handleTap(x, y) {
            const btn = getButtonRect();
            if (x >= btn.x && x <= btn.x + btn.w && y >= btn.y && y <= btn.y + btn.h) {
                showingLetter = true;
                letterScrollY = 0;
                return;
            }
            const closeW = Math.min(100, canvas.width * 0.25);
            const closeH = Math.max(36, canvas.height * 0.055);
            const closeX = canvas.width - closeW - 20;
            const closeY = 55;
            if (showingLetter && x >= closeX && x <= canvas.width - 20 && y >= closeY && y <= closeY + closeH) {
                showingLetter = false;
                return;
            }
            if (showingLetter && x >= 50 && x <= canvas.width - 50 && y >= 50 && y <= canvas.height - 50) {
                letterScrollY = Math.min(letterScrollY + scrollStep, maxScroll);
                return;
            }
            if (!showingLetter) {
                flowers.push({ x: x, y: y });
            }
        }
        
        canvas.addEventListener('click', function(event) {
            const coords = getCanvasCoords(event);
            handleTap(coords.x, coords.y);
        });
        
        // Soporte táctil: evitar doble disparo con click y usar touch
        let lastTouchEnd = 0;
        canvas.addEventListener('touchend', function(event) {
            if (event.changedTouches.length) {
                const t = event.changedTouches[0];
                const rect = canvas.getBoundingClientRect();
                const scaleX = canvas.width / rect.width;
                const scaleY = canvas.height / rect.height;
                const x = (t.clientX - rect.left) * scaleX;
                const y = (t.clientY - rect.top) * scaleY;
                const now = Date.now();
                if (now - lastTouchEnd < 300) return;
                lastTouchEnd = now;
                event.preventDefault();
                handleTap(x, y);
            }
        }, { passive: false });
        
        // Desplazar la carta con la rueda del ratón
        canvas.addEventListener('wheel', function(event) {
            if (showingLetter) {
                event.preventDefault();
                if (event.deltaY > 0) {
                    letterScrollY = Math.min(letterScrollY + scrollStep, maxScroll);
                } else {
                    letterScrollY = Math.max(0, letterScrollY - scrollStep);
                }
            }
        }, { passive: false });
        
        // Desplazar la carta con el dedo (móvil)
        let touchStartY = 0;
        let scrollStartY = 0;
        canvas.addEventListener('touchstart', function(event) {
            if (showingLetter && event.touches.length === 1) {
                touchStartY = event.touches[0].clientY;
                scrollStartY = letterScrollY;
            }
        }, { passive: true });
        canvas.addEventListener('touchmove', function(event) {
            if (showingLetter && event.touches.length === 1) {
                event.preventDefault();
                const dy = touchStartY - event.touches[0].clientY;
                letterScrollY = Math.max(0, Math.min(maxScroll, scrollStartY + dy));
            }
        }, { passive: false });

        function drawHeartCoreGlow() {
            ctx.save();
            const cx = canvas.width / 2;
            const cy = canvas.height / 3;
            const pulse = 1 + 0.04 * Math.sin(Date.now() * 0.002);
            const r = Math.min(canvas.width, canvas.height) * 0.35 * pulse;
            const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, r);
            grad.addColorStop(0, 'rgba(180, 120, 255, 0.12)');
            grad.addColorStop(0.4, 'rgba(100, 180, 255, 0.06)');
            grad.addColorStop(0.7, 'rgba(50, 150, 220, 0.02)');
            grad.addColorStop(1, 'rgba(0, 100, 180, 0)');
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = grad;
            ctx.fillRect(cx - r, cy - r, r * 2, r * 2);
            ctx.restore();
        }

        function drawHeartOutline() {
            ctx.save();
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 3;
            const outlineScale = Math.min(8, canvas.width / 70, canvas.height / 70);
            const cosAngle = Math.cos(heart3DRotation);
            const sinAngle = Math.sin(heart3DRotation);
            
            const sideView = 1 - Math.abs(cosAngle);
            
            function buildHeartPath(offsetX, offsetY) {
                ctx.beginPath();
                for (let t = 0; t < Math.PI * 2; t += 0.04) {
                    const px = outlineScale * 16 * Math.pow(Math.sin(t), 3);
                    const py = -outlineScale * (13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t));
                    const depthFactor = px / (outlineScale * 20);
                    const rotX = px * cosAngle + depthFactor * sinAngle * outlineScale * (3 + sideView * 2);
                    const scaleD = Math.max(0.5 - sideView * 0.2, 1 - Math.abs(depthFactor) * (0.25 + sideView * 0.2));
                    const tiltY = depthFactor * sinAngle * outlineScale * 2 * sideView;
                    const x = centerX + rotX * scaleD + offsetX;
                    const y = centerY + py + tiltY + offsetY;
                    t === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
                }
                ctx.closePath();
            }
            
            const shadowOffset = 5 + (10 + sideView * 14) * Math.abs(sinAngle);
            buildHeartPath(shadowOffset, shadowOffset);
            ctx.fillStyle = `rgba(0, 30, 60, ${0.4 + sideView * 0.25})`;
            ctx.fill();
            
            buildHeartPath(0, 0);
            ctx.globalCompositeOperation = 'lighter';
            ctx.fillStyle = `rgba(120, 180, 255, ${0.03 + 0.02 * (1 - sideView)})`;
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            
            for (let i = 0; i < 5; i++) {
                const offset = (i - 2) * 2.8;
                const alpha = 0.6 - i * 0.12;
                buildHeartPath(offset, offset);
                ctx.strokeStyle = `rgba(80, 200, 255, ${alpha})`;
                ctx.lineWidth = 2.8;
                ctx.stroke();
            }
            
            buildHeartPath(0, 0);
            ctx.strokeStyle = `rgba(180, 235, 255, ${0.95})`;
            ctx.lineWidth = 2.2;
            ctx.stroke();
            
            buildHeartPath(0, 0);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 1;
            ctx.stroke();
            
            ctx.restore();
        }

        // Iniciar la animación
        animate();
    </script>
</body>
</html>